$group
    $params &md

    export
        function clonePackiFiles
            param packiFiles
                :union
                    :string
                    :ref PackiFiles
            param filters
                :[
                    :string
                :optional
            :return
                $if TODO
                    :ref PackiFiles
                :any
            +
            const testPackiFilesObj
                _ packiFilesToObject
                    @ packiFiles
            if testPackiFilesObj.__is_error
                return testPackiFilesObj
            +
            const packiFilesObj
                :ref PackiFiles
                = testPackiFilesObj as PackiFiles
            set filters = filters || []
            function isOk
                param filename
                    :string
                if !filters || filters.length == 0
                    return true
                _ filters.forEach
                    =>
                        param filter
                        if filename.startsWith(filter)
                            return true
                return false
            const retval 
                :ref PackiFiles
                =
                    {
            for const k in packiFilesObj
                if isOk(k)
                    set retval[k] = packiFilesObj[k]
            return retval

    export
        function extractPackiFileContent
            param packiFiles
                :union
                    :string
                    :ref PackiFiles
            param filePath
                :string
            param options
                :{
                    :p json
                        :boolean
            :return
                $if TODO
                    :ref PackiFileContent
                :any
            $$ info "api.${md.ApiName}.extractPackiFileContent.packiFiles,filePath", packiFiles, filePath
            +
            const testPackiFileObj
                _ extractPackiFile
                    @ packiFiles
                    @ filePath
            $$ info "api.${md.ApiName}.extractPackiFile.testPackiFileObj", testPackiFileObj
            if testPackiFileObj && testPackiFileObj.__is_error
                return testPackiFileObj
            +
            let retval
                $if TODO
                    :ref PackiFileContent
                :any
                {
                    @ exists !!testPackiFileObj
                    @ text (testPackiFileObj && testPackiFileObj.contents) || (options.json ? '{}' : '')
            if options.json
                try
                    set retval.json = testPackiFileObj && JSON.parse(testPackiFileObj.contents) || {}
                    $$ info "api.${md.ApiName}.extractPackiFile.testPackiFileObj.contents.json", retval.json
                catch err
                    info "Error in ${md.ApiName}.extractPackiFileContent parsing packiFile contents", err, testPackiFileObj.contents
                    set retval
                        {
                            @ __is_error true
                            @ message "Error parsing packiFile contents"
                            @ contents testPackiFileObj.contents
            return retval

    export
        function extractPackiFile
            param packiFiles
                :union
                    :string
                    :ref PackiFiles
            param filePath
                :string
            :return
                $if TODO
                    :ref PackiFile
                :any
            +
            const testPackiFilesObj
                _ packiFilesToObject
                    @ packiFiles
            if testPackiFilesObj.__is_error
                return testPackiFilesObj
            +
            $$ info "api.${md.ApiName}.extractPackiFile", testPackiFilesObj
            return testPackiFilesObj[filePath] 

    export
        function packiFilesToObject
            param packiFiles
                :union
                    :string
                    :ref PackiFiles
            :return
                $if TODO
                    :ref PackiFiles
                :any
            if typeof packiFiles === "string"
                try
                    return JSON.parse(packiFiles)
                catch err
                    error "${md.ApiName}.packiFilesToObject. Error parsing packiFiles", err, packiFiles
                    return
                        {
                            @ __is_error true
                            @ message "Error parsing packiFiles string"
                            @ packiFiles
            else
                return packiFiles

    export
        function packiToEntryArray
            param files
                :ref PackiFiles
            :return
                :[
                    :ref PackiEntry
            $$ info '=========='
            $$ info 'Begin packiToEntryArray'
            $$ info '=========='
            const fileSystem
                :[
                    :ref PackiEntry
                = []
            const fs
                :{
                    :index
                        :ref PackiEntry
                        param uri
                            :string
                = {}
            const state
                :{
                    :p count
                        :number
                { 
                    @ count 0
            for const filename of Object.keys(files).sort()
                _ setFileEntry
                    @ filename
                    @ files[filename].contents
                    @ fs
                    @ state
            for const uri in fs
                _ fileSystem.push
                    @ fs[uri]
            $$ info '=========='
            $$ info 'End packiToEntryArray'
            $$ info '=========='
            return fileSystem

    function setFileEntry
        param filename
            :string
        param contents
            :string
        param fs
            :{
                :index
                    :ref PackiEntry
                    param uri
                        :string
        param state
            :{
                :p count
                    :number
        const parts = filename.split('/')
        let uri = ''
        let parentUri = ''
        let folderObj
            :union
                :ref PackiEntry
                :null
            = null
        for var i=0; i<parts.length-1; i++
            let part = parts[i]
            set parentUri = uri
            set uri += (uri.length > 0 ? '/' : '') + part
            set folderObj = fs[uri]
            $$ info 'setFileEntry.part', filename, part, 'parentUri', parentUri, 'uri', uri, 'folderObj', folderObj
            if !folderObj
                set folderObj
                    {
                        @ id ++state.count + ''
                        @ type 'folder'
                        @ uri uri
                        @ name part
                        [ children
                set fs[uri] = folderObj
            if parentUri.length > 0
                let parentFolderObj = fs[parentUri]
                if parentFolderObj && parentFolderObj.children
                    $$ info 'has parentFolderObj', parentFolderObj
                    const found
                        _ parentFolderObj.children.filter
                            =>
                                param item
                                return item == folderObj?.uri
                    $$ info 'found', found
                    if found.length == 0
                        $$ info 'add to parentFolderObj.children', folderObj.uri
                        _ parentFolderObj.children.push
                            @ folderObj.uri
                    else
                        $$ info 'already in parentFolderObj.children', folderObj.uri
                else
                    $$ info 'no parentFolderObj'
            else
                $$ info 'no parentUri'
        let fileObj
            :ref PackiEntry
            {
                @ id ++state.count + ''
                @ type 'file'
                @ uri filename
                @ name parts[parts.length-1]
                @ contents contents
        set fs[filename] = fileObj
        if folderObj && folderObj.children
            _ folderObj.children.push
                @ fileObj.uri
        $$ info 'setFileEntry.fs', fs

    export 
        function mountToPackiFolder
            param packiFiles
                :ref PackiFiles
            param packiFilesTobeMounted
                :ref PackiFiles
            param folderName
                :string
            :return
                :ref PackiFiles
            for var k in packiFilesTobeMounted
                let basename = k
                let prefix = ''
                if k.startsWith(packiFilePrefix)
                    set basename = k.substring(packiFilePrefix.length)
                    set prefix = packiFilePrefix
                set packiFiles[prefix + folderName + '/' + basename] = packiFilesTobeMounted[k]
            return packiFiles

    export 
        function unmountPackiFolder
            param packiFiles
                :ref PackiFiles
            param folderName
                :string
            :return
                :ref PackiFiles
            const result
                :ref PackiFiles
                = {}
            for var k in packiFiles
                let basename = k
                let prefix = ''
                if k.startsWith(packiFilePrefix)
                    set basename = k.substring(packiFilePrefix.length)
                    set prefix = packiFilePrefix
                if basename.startsWith(folderName)
                    set result[prefix + basename.substring(folderName.length+1)] = packiFiles[k]
            return result

    export 
        function mergePackiFiles
            param packiFilesA
                :ref PackiFiles
            param packiFilesB
                :ref PackiFiles
            :return
                :ref PackiFiles
            const retval
                :ref PackiFiles
                = {}
            for var k in packiFilesA
                set retval[k] = packiFilesA[k]
            for var k in packiFilesB
                set retval[k] = packiFilesB[k]
            return retval